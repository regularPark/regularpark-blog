---
title: '[우아한테크코스] TanStack Query 도입기'
date: 2023-10-15
thumbnail: /assets/level3/earn_stamp.png
categories: FE,우아한테크코스,스탬프크러쉬,탠스택쿼리
---

---

# 도입 계기

레벨3에 들어와 프로젝트를 진행하면서 통신 코드를 작성할 일이 많아졌는데요. 특히 저희 프로젝트는 가입에 대한 프로세스를 조금은 다르게 가져가고자 했습니다.

저희 팀의 서비스는 쿠폰을 관리하기 어려워하는 사장님과 고객 모두를 타겟으로 한 서비스인데요. 쿠폰에 스탬프를 적립하기 위해 전화번호를 입력하는 프로세스를 갖고 있습니다. 이때, 기존에 가입되어 있는, 그러니까 전화번호를 입력한 적이 있는 고객인지를 파악하고, 그렇지 않으면 임시회원으로 가입하고, 해당 전화번호로 적립된 쿠폰이 있는지, 해당 쿠폰이 현재 방문한 카페인지를 판단하는, 다수의 통신을 **_전화번호를 입력받는 단 한번의 이벤트_**와 함께 진행하도록 하였습니다.

이해를 돕기 위해 그림과 함께 설명하겠습니다. 아래 그림은 그 중에서도 가장 복잡한 경우를 도식화한 건데요.

![신규 적립](/assets/level3/earn_stamp.png)

보시다시피 적립 기능에는 전화번호 입력 단 한번으로 스탬프 적립 페이지로 이동하기까지 api call이 다섯 차례 일어나게 됩니다.

저희 팀에서는 프로젝트 초창기부터 서버 상태 관리 라이브러리, 그러니까 탠스택 쿼리 같은 라이브러리를 섣불리 도입하는 것을 꺼려했습니다. 일단 기술 도입에는 러닝커브가 존재하고, 기술 도입으로 인한 사이드이펙트가 있을 수 있으며, 리액트, 자바스크립트 내장 기능으도로 충분히 구현가능하다고 믿었기 때문입니다.

하지만 내장 API만으로 기능을 구현하다보니 아래와 같은 어려움을 마주하게 됐습니다.

1. 코드의 길이가 길어도 **너무** 길다.
2. 코드가 길어짐에 따라 가독성이 떨어지고, 때문에 유지보수가 어려워졌다.
3. 통신 코드의 로딩/에러 핸들링을 위한 상태가 덩달아 많아졌다.

특히 코드 길이에 따른 개발 경험이 너무 좋지 않았기 때문에 팀 내 회의를 거쳐 TanStack Query를 도입하기로 결정하였습니다.

## 왜 TanStack Query인가?

TanStack Query를 선택한 이유는 저희 프로젝트가 직면한 위와 같은 문제들에 대한 해결책을 제공하기 때문입니다. 프로젝트에서 데이터 통신이 중요한 부분을 차지하고 있는데요. 특히 복잡한 통신 프로세스가 존재합니다. 이런 상황에서 TanStack Query는 다음과 같은 이유로 적합하다고 판단했습니다:

1. **코드의 간결성과 가독성 향상**: 데이터 로딩, 캐싱, 업데이트 및 에러 처리 로직을 간단하고 일관된 방식으로 구현할 수 있습니다. 이는 코드의 길이를 줄이고, 가독성을 높이며, 유지보수를 용이하게 합니다.

2. **강력한 에러 핸들링**: 에러 핸들링과 데이터 재시도 기능을 제공합니다. 이는 네트워크 요청 실패 시 자동으로 재시도하는 등의 기능을 통해 안정성과 사용자 경험을 향상시키는 기능을 가지고 있습니다.

3. **자동화된 데이터 동기화**: 백그라운드에서 데이터를 자동으로 새로고침하고 동기화하는 기능을 제공합니다. 이는 한 번의 이벤트로 다수의 API 호출을 관리해야 하는 복잡한 시나리오에 매우 유용합니다. 사용자가 수동으로 데이터를 새로고침할 필요가 없어지므로, 사용자 경험이 개선됩니다.

4. **커뮤니티와 문서의 강점**: 사용자가 많기 때문에 다수의 커뮤니티 지원과 잘 정리된 문서를 가지고 있습니다. 이는 러닝 커브를 낮추고, 개발 과정에서 발생할 수 있는 문제들을 해결하는 데 도움이 됩니다.

5. **효율적인 상태 관리**: 서버 상태를 캐싱하고, 상태 업데이트를 최적화합니다. 이는 복잡한 상태 관리 로직을 단순화시켜 개발자가 통신 관련 코드에 더 집중할 수 있게 해줍니다.

사실 1,2번만으로도 도입하기에는 충분한 이유였는데요. TanStack Query에 대해서 학습할수록 서버 상태를 관리하기 아주 용이해지겠다는 인상을 받았습니다. 저희 프로젝트와 같이 다수의 연속된 API 호출을 관리해야 하는 경우에는 적합하다고 판단했고, 기술 도입에 따른 초기 러닝 커브가 있을 수 있지만, 장기적으로는 프로젝트의 효율성과 유지보수 용이성을 향상시킬 것에 팀원 모두 동의하였습니다.

---

# 도입 과정

Fetch API만을 사용하여 통신하던 코드를 추상화하여 보여드리자면 이렇습니다.

```ts
import React, { useState, useEffect } from 'react';

const EarnStamp = ({ phoneNumber }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    // 고객 조회
    const getCustomer = async () => {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(`www.stampcrush.site/${phoneNumber}`);
        if (!response.ok) {
          throw new Error(`Error: ${response.status}`);
        }

        const data = await response.json();
        setUserData(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    earnStamp();
  }, [phoneNumber]);

  if (loading) {
    return <p>Loading...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return <div>{/** something */}</div>;
};
```

위와 유사형태를 가지면서, 많은 로직을 포함한 통신 코드가 6개 필요하고, 서버에서 응답받은 상태를 개별적으로 관리하며 동시에 응답받은 상태에 따라 분기 처리를 해주어야 했습니다.

```ts
import React from 'react';
import { useQuery } from 'react-query';

const fetchCustomer = async phoneNumber => {
  const response = await fetch(`www.stampcrush.site/${phoneNumber}`);
  if (!response.ok) {
    throw new Error(`Error: ${response.status}`);
  }
  return response.json();
};

const EarnStamp = ({ phoneNumber }) => {
  const { data, isLoading, error } = useQuery(['customer', phoneNumber], () =>
    fetchCustomer(phoneNumber),
  );

  if (isLoading) {
    return <p>Loading...</p>;
  }

  if (error) {
    return <p>Error: {error.message}</p>;
  }

  return <div>{/* something */}</div>;
};
```

하지만 탠스택 쿼리로 마이그레이션하는 과정에서 코드가 짧아지고 직관적으로 변했으며, 이전보다 관심사를 분리하기에도 편리하게 되었습니다.

그리고 무엇보다도 효용을 느낀 부분은 `useQuery`, `useMutation` 내부에서 사용할 수 있는 다양한 메서드들이었습니다.

fulfilled 상태가 됐을 때 `onSuccess`, rejected 상태에서의 `onError`, 응답 데이터 객체를 구조분해할당해서 반환할 수 있는 `select`, rejected 됐을 때 리페칭 횟수를 정할 수 있는 `retry` 등 분기처리가 많은 적립 프로세스에서 유용하게 분기처리를 할 수 있는 메서드들이 존재했고, 이 메서드들로 인해 개발 경험이 향상됐습니다.

물론 라이브러리 도입 후 매끄럽게 진행되었다면 더욱 좋았겠지만, 고난이 없으면 성장도 없는 법.

도입한 지 얼마 되지 않은 데모데이 주간이었습니다. 저희 팀에서는 사용자 경험을 향상하기 위해 적립 프로세스에서 쿠폰 디자인 API를 새로 추가해 적립 페이지에서도 사용자의 쿠폰 디자인과 스탬프을 렌더링하도록 하자는 합의가 있었습니다.

대망의 데모데이 D-1. API가 완성됐고, MSW를 통해 API 통신은 이미 대비가 완료된 상태. 그런데! 업로드한 디자인을 불러오지 않고 최초에 가져왔던 디자인만을 보여주더군요.

한번 페칭한 데이터를 **다시 페칭을 해오지 않는 문제**가 발생한 것이죠. 해당 `useQuery`문에는 cacheTime, staleTime(당시 탠스택쿼리V4)는 설정해주지 않았는데도 페칭을 해오지 않았습니다.

그래서 강제로 다시 페칭을 하고자

1. `useQuery`의 메서드인 `refetch`
2. `invalidateQueries`를 사용하여 강제로 페칭하기

두 가지 방법을 사용했으나 꿈쩍도 않는 이미지들. 시간은 속절없이 흘러 데모데이 D-1 오후 10시.. 캠퍼스에서 밤을 새겠다는 각오(11시엔 나가야함)로 트러블슈팅에 매달렸습니다.

<div align="center">
  <img
    src="/assets/level3/떠나가지못하는남자.jpeg"
    width="250"
    style={{ marginBottom: '0' }}
    alt="떠나가지 못하는 남자"
  />
  <p style={{ color: 'gray', fontSize: '12px', height: '12px' }}>
    집에 가고 싶은 몸과 그렇지 않은 머리
  </p>
</div>

강제 퇴근 직전, 라잇이 한마디 던집니다. "레고, 쿼리키 확인하셨어요?". "네".

쿼리키는 진즉 확인했습니다. 그렇게 생각했습니다. 하지만 퇴근길 지하철에서 확인해보니 동일한 쿼리키를 그 주 초에 새로 추가된 API 통신 코드에서 발견한 것입니다..😱😱😱😇

그렇습니다. 동일한 쿼리 키가 존재했던 것입니다.

그래서 쿼리 키란 무엇인가..

## Query Key

> 쿼리 키를 기반으로 쿼리 캐싱을 관리합니다. 쿼리 키는 최상위 수준의 배열이어야 하며, 하나의 문자열을 사용하는 배열처럼 단순할 수도 있고, 많은 문자열과 중첩된 개체의 배열처럼 복잡할 수도 있습니다. 쿼리 키가 직렬화 가능하고 **쿼리 데이터에 고유한 경우에만 사용할 수 있습니다.**<br/>[TanStack Query docs](https://tanstack.com/query/v4/docs/react/guides/query-keys)

쿼리 키의 특징 중 고유해야 한다는 것에 주목하면 제가 겪은 문제를 해결할 수 있는 단서를 얻게 됩니다.

동일한 쿼리 키를 가진 쿼리는 같은 캐시 데이터를 공유합니다. 즉, 두 개 이상의 다른 쿼리가 동일한 쿼리 키를 사용하면, 탠스택 쿼리는 이들이 동일한 데이터를 요청하는 것으로 간주하고, 동일한 캐시 항목을 이들 사이에서 공유합니다.

그렇기 때문에 아무리 제가 새로운 쿠폰 디자인을 요청해도 페칭하지 않았던 것이죠! 따라서 쿼리 키에 고유성을 부여하여 해당 문제를 해결하였습니다.

---

# 도입 후기

다소 시행착오가 있었지만, 탠스택 쿼리 도입은 저희 프로젝트에 있어 큰 전환점이 되었습니다. 우선 가장 눈에 띄는 변화는 코드의 간결성과 명료성이었습니다. 이전에는 길고 복잡한 통신 코드와 상태 관리 로직으로 인해 코드가 지나치게 방대해지고 관리하기 어려웠습니다. 하지만 탠스택 쿼리의 도입으로 통신 코드가 대폭 간소화되었고, 상태 관리가 훨씬 용이해졌습니다.

에러 핸들링과 데이터 로딩 처리 또한 더욱 효율적으로 이루어졌는데요. 정교한 에러 처리와 데이터 관리가 가능해졌고, 곧 사용자 경험의 개선으로 이어질 수 있었습니다.

결과적으로 TanStack Query의 도입은 러닝 커브와 적응이 필요했지만, 결과적으로는 개발 생산성을 크게 향상시켰습니다. 앞으로도 서버 상태 관리 라이브러리를 사용한다면 탠스택 쿼리를 선택하게 될 것 같습니다.😁👍

---
